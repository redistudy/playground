# Chapter 06. 레디스를 메시지 브로커로 사용하

## 1. 메시징 큐와 이벤트 스트림

### 1) 메시징 큐와 이벤트 스트림의 차이점

1. 방향성
   - 메시징 큐 방식
     - 생산자는 소비자의 큐로 데이터를 직접 푸시
     - 2개의 서비스에 같은 메시지를 보내야 할 때, 각각 다를 메시징 큐에 각각 데이터를 푸시해야 함
   - 이벤트 스트림
     - 스트림의 특정 저장소에 하나의 메시지를 보내고, 여러 소비자가 같은 데이터를 풀할 수 있음
2. 데이터의 영속성
   - 메시징 큐
     - 소비자가 데이터를 읽어갈 때, 큐에서 메시지를 삭제한다.
   - 이벤트 스트림
     - 소비자가 삭제하는 방식이 아니라, 특정 시간 혹은 조건에 따라 메시지가 삭제된다.

> - 메시징 큐 방식은 1:1 상황에서 유리함
> - 이벤트 스트림 방식은 N:N 상황에서 유리

### 2) 레디스를 메시지 브로커로 사용하기

레디스 pub/sub 기능에서 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 일회성의 특징을 가지며,
메시지가 잘 전달됐는지 등의 정보는 보장하지 않음

완벽하게 데이터가 전달돼야 하는 상황에서는 적합하지 않음

fire-and-forgot 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용될 수 있음

> #### fire-and-forgot pattern
> 비동기 프로그래밍 방식에서 사용되는 디자인 패턴.
> 어떤 작업을 수행하 그 결과에 대한 응답을 기다리지 않고, 바로 다음 작업을 수행하는 방식.
> 작업의 완료나 결과에 대한 처리가 필요하지 않을 때 사용하는 패턴.
> 로깅, 이벤트 발생, 통계 데이터 수집과 같이 작업의 성공 혹은 실패에 대한 관심이 없을 때 사용.
> 신뢰성이 필요한 상황에서는 사용할 수 없음.

* `list`: 메시징 큐 방식에서 사용. 블로킹 기능이 있어 매번 확인하지 않아도 됨.
* `stream`: 카프카에 영감을 받아 만들어진 자료 구조. 데이터를 계속 추가하는 방식으로 구성(append-only).

### 3) 레디스의 pub/sub

최소한의 메시지 전달 기능만 제공.
발행자의 메타 정보, 구독자의 정보, 메시지 전달 여부에 대한 책임을 지지 않음.
정합성이 중요한 데이터일 경우 적합하지 않음.

#### (1) 메시지 publish 하기

```shell
PUBLISH hello world
```

`hello` 채널을 수신하는 모든 소비자에게 `world`라는 메시지가 전달됨.
메시지를 수신한 구독자의 수를 반환함.

#### (2) 메시지 subscribe 하기

```shell
SUBSCRIBE event1 event2
PSUBSCRIBE mail-1 mail-*
```

#### (3) 클러스터 구조에서의 pub/sub

아무 노드에 이벤트가 발생하면 모든 노드에 전파해 주고, 소비자에게 메시지가 잘 전달되기는 한다.
하지만 클러스터 내에서 불필요한 리소스 사용과 네트워크 부하를 발생시키기 때문에, 클러스터 환경에서는 적절하지 않음.

#### (4) sharded pub/sub

클러스터 구조에서의 비효율을 줄이고자 고안된 방식.
같은 슬롯을 가지고 있는 노드 간에만 이벤트 전파 및 데이터 복제가 일어남.

```shell
SPUBLISH apple a

SSUBSCRIBE apple
-> Redirected to slot [xxxx] located at 10.0.0.0 # apple 키를 가지는 마스터 노드로 리다이렉트 된다.
1) "ssubscribe"
2) "apple"
3) (integer) 1
1) "smessage"
2) "apple"
3) "a"
```

### 4) 레디스의 `list`를 메시징 큐로 사용하기

#### (1) `list`의 `EX` 기능

X(트위터)에서 활용하는 방식으로, 키가 존재하는 리스트에만 데이터를 푸시할 수 있는 기능

```shell
RPUSHX queue:1 message-1
(integer) 0 # 키 queue:1이 없을 경우 아무 일도 일어나지 않는다.

RPUSH queue:1 message-2
(integer) 1 # 키가 생성되고, 새로운 메시지가 들어 있는 상태가 되면

RPUSHX queue:1 message-3
(integer) 2 # RPUSHX 메시지가 정상적으로 수행되어 큐에 담긴 메시지가 2개임이 확인된다.
```

#### (2) `list`의 블로킹 기능

이벤트 기반 구조에서 시스템은 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 체크한다.
이벤트 여부를 체크할 때, 이벤트가 없을 경우 정해진 시간 동안 대기한다(polling interval).
대기 후에 다시 이벤트가 있는지 체크하는 방식을 폴링(polling)이라고 하며,
폴링 프로세스가 진행되는 동안 애플리케이션과 큐의 리소스가 불필요하게 소모될 수 있다.
또한 인터벌 기간 동안 새로운 이벤트가 들어올 경우, 인터벌이 끝날 때까지 바로 이벤트를 처리할 수 없다.

반대로 `list`의 블로킹 기능을 사용하면, 이와 같은 불필함을 줄일 수 있다.
`BRPOP`, `BLPOP` 등을 활용하여 정해진 시간 동안 리스트를 바라보고 있다가,
데이터가 들어오면 데이터를 가져오고, 정해진 시간이 지날 경우 `nil` 값을 가져온다.

#### (3) `list`를 이용한 원형 큐

`RPOPLPUSH` 명령어를 활용하여 원형큐를 지원한다.

### 5) Stream

#### (1) 레디스의 `Stream`과 아파치의 `Kafka`

5.0 버전에서 추가됨.
append-only 방식의 자료 구조.

#### (2) 스트림이란?

컴퓨터 과학에서 스트림이란 연속적인 데이터의 흐름, 일정한 데이터 조각의 연속을 의미한다.

#### (3) 데이터의 저장

카프카에서 메시지는 0부터 시작해 증가하는 시퀀스 넘버로 식별할 수 있음.
이때 시퀀스 넘버는 토픽 내의 파티션 안에서만 유니크하게 증가하므로
토픽이 1개 이상의 파티션을 가진다면 메시지는 하나의 토픽 내에서 유니크하게 식별되지 않는다.

레디스 stream에서 각 메시지는 시간과 관련된 유니크한 ID를 가지며, 이 값은 중복되지 않는다.
이와 같은 특징 때문에 시간을 이용해 특정 데이터를 검색할 수 있다.

```text
<millisecondsTime>-<sequenceNumber>
```

#### (4) 스트림 생성과 데이터 입력

카프카에서 각 스트림은 토픽이라는 이름으로 관리된다.
생성자는 데이터를 토픽에 푸시하며, 소비자는 토픽에서 데이터를 읽어간다.

```shell
$ kafka-topics --zookeeper 127.0.0.1:6000 --topic Email --create partitions
1 --replication-factor 1

$ kafka-console-consumer --brokers-list 127.0.0.1:7000 --topic Email
> "I am first email"
> "I am second email"
```

레디스에서는 따로 stream 생성 과정은 필요하지 않으며,
`XADD` 커맨드를 이용해 새로운 이름의 stream에 데이터를 저장하면 데이터의 저장과 동시에 stream 자료 구조가 생성된다.

```shell
> XADD Email * subject "first" body "hello?"
"1234567812345-0" # redis timestamp id
# <millisecondsTime>-<sequenceNumber>
```

`*` 필드는 저장되는 데이터의 ID를 의미하며, `*`로 입력할 경우 레디스에서 자동 생성되는 타임스탬프 ID를 사용한다.
